// This file is auto-generated by @hey-api/openapi-ts

/**
 * An attachment for an email message.
 */
export type Attachment = {
    Name?: string;
    Content?: string;
    ContentType?: string;
    ContentID?: string;
};

export type AttachmentCollection = Array<Attachment>;

export type BounceActivationResponse = {
    Message?: string;
    Bounce?: BounceInfoResponse;
};

export type BounceCountElement = {
    Name?: string;
    Count?: number;
    Type?: string;
};

export type BounceDumpResponse = {
    /**
     * Raw source of bounce. If no dump is available this will return an empty string.
     */
    Body?: string;
};

export type BounceInfoResponse = {
    ID?: string;
    Type?: string;
    TypeCode?: number;
    Name?: string;
    Tag?: string;
    MessageID?: string;
    Description?: string;
    Details?: string;
    Email?: string;
    BouncedAt?: string;
    DumpAvailable?: boolean;
    Inactive?: boolean;
    CanActivate?: boolean;
    Subject?: string;
    Content?: string;
};

export type BounceSearchResponse = {
    TotalCount?: number;
    Bounces?: Array<BounceInfoResponse>;
};

export type CreateInboundRuleRequest = {
    Rule?: string;
};

/**
 * The contents required for creating a new template.
 */
export type CreateTemplateRequest = {
    /**
     * The optional string identifier for referring to this Template (numbers, letters, and '.', '-', '_' characters, starts with a letter).
     */
    Alias?: string;
    /**
     * The friendly display name for the template.
     */
    Name: string;
    /**
     * The Subject template definition for this Template.
     */
    Subject: string;
    /**
     * The HTML template definition for this Template.
     */
    HtmlBody?: string;
    /**
     * The Text template definition for this Template.
     */
    TextBody?: string;
};

export type DeliveryStatsResponse = {
    InactiveMails?: number;
    Bounces?: Array<BounceCountElement>;
};

/**
 * The properties of this object will vary based request parameters.
 */
export type DynamicResponse = {
    [key: string]: unknown;
};

export type EditServerConfigurationRequest = {
    Name?: string;
    Color?: 'purple' | 'blue' | 'turqoise' | 'green' | 'red' | 'yellow' | 'grey';
    RawEmailEnabled?: boolean;
    DeliveryHookUrl?: string;
    SmtpApiActivated?: boolean;
    InboundHookUrl?: string;
    BounceHookUrl?: string;
    OpenHookUrl?: string;
    PostFirstOpenOnly?: boolean;
    TrackOpens?: boolean;
    TrackLinks?: 'None' | 'HtmlAndText' | 'HtmlOnly' | 'TextOnly';
    /**
     * Webhook url allowing real-time notification when tracked links are clicked.
     */
    ClickHookUrl?: string;
    InboundDomain?: string;
    InboundSpamThreshold?: number;
};

export type Color = 'purple' | 'blue' | 'turqoise' | 'green' | 'red' | 'yellow' | 'grey';

export type TrackLinks = 'None' | 'HtmlAndText' | 'HtmlOnly' | 'TextOnly';

/**
 * The contents required for creating a new template.
 */
export type EditTemplateRequest = {
    /**
     * The optional string identifier for referring to this Template (numbers, letters, and '.', '-', '_' characters, starts with a letter).
     */
    Alias?: string;
    /**
     * The friendly display name for the template.
     */
    Name?: string;
    /**
     * The Subject template definition for this Template.
     */
    Subject?: string;
    /**
     * The HTML template definition for this Template.
     */
    HtmlBody?: string;
    /**
     * The Text template definition for this Template.
     */
    TextBody?: string;
};

export type EmailNameAddressPair = {
    Name?: string;
    Email?: string;
};

export type EmailWithTemplateRequest = {
    /**
     * Required if 'TemplateAlias' is not specified.
     */
    TemplateId: number;
    /**
     * Required if 'TemplateId' is not specified.
     */
    TemplateAlias: string;
    TemplateModel: {
        [key: string]: unknown;
    };
    InlineCss?: boolean;
    From: string;
    To: string;
    Cc?: string;
    Bcc?: string;
    Tag?: string;
    ReplyTo?: string;
    Headers?: HeaderCollection;
    /**
     * Activate open tracking for this email.
     */
    TrackOpens?: boolean;
    /**
     * Replace links in content to enable "click tracking" stats. Default is 'null', which uses the server's LinkTracking setting'.
     */
    TrackLinks?: 'None' | 'HtmlAndText' | 'HtmlOnly' | 'TextOnly';
    Attachments?: AttachmentCollection;
};

export type ExtendedMessageClickEventInformation = {
    ClickLocation?: string;
    Client?: {
        Name?: string;
        Company?: string;
        Family?: string;
    };
    OS?: {
        Name?: string;
        Company?: string;
        Family?: string;
    };
    Platform?: string;
    UserAgent?: string;
    OriginalLink?: string;
    Geo?: {
        CountryISOCode?: string;
        Country?: string;
        RegionISOCode?: string;
        Region?: string;
        City?: string;
        Zip?: string;
        Coords?: string;
        IP?: string;
    };
    MessageID?: string;
    ReceivedAt?: string;
    Tag?: string;
    Recipient?: string;
};

export type ExtendedMessageOpenEventInformation = {
    FirstOpen?: boolean;
    Client?: {
        Name?: string;
        Company?: string;
        Family?: string;
    };
    OS?: {
        Name?: string;
        Company?: string;
        Family?: string;
    };
    Platform?: string;
    UserAgent?: string;
    Geo?: {
        CountryISOCode?: string;
        Country?: string;
        RegionISOCode?: string;
        Region?: string;
        City?: string;
        Zip?: string;
        Coords?: string;
        IP?: string;
    };
    MessageID?: string;
    ReceivedAt?: string;
    Tag?: string;
    Recipient?: string;
};

export type HeaderCollection = Array<MessageHeader>;

export type InboundMessageDetail = {
    From?: string;
    FromName?: string;
    FromFull?: {
        Email?: string;
        Name?: string;
    };
    To?: string;
    ToFull?: Array<EmailNameAddressPair>;
    Cc?: string;
    CcFull?: Array<EmailNameAddressPair>;
    ReplyTo?: string;
    OriginalRecipient?: string;
    Subject?: string;
    Date?: string;
    MailboxHash?: string;
    Tag?: string;
    Attachments?: AttachmentCollection;
    MessageID?: string;
    Status?: string;
};

export type InboundMessageFullDetailsResponse = {
    From?: string;
    FromName?: string;
    FromFull?: {
        Email?: string;
        Name?: string;
    };
    To?: string;
    ToFull?: Array<EmailNameAddressPair>;
    Cc?: string;
    CcFull?: Array<EmailNameAddressPair>;
    ReplyTo?: string;
    OriginalRecipient?: string;
    Subject?: string;
    Date?: string;
    MailboxHash?: string;
    TextBody?: string;
    HtmlBody?: string;
    Tag?: string;
    Headers?: HeaderCollection;
    Attachments?: AttachmentCollection;
    MessageID?: string;
    BlockedReason?: string;
    Status?: string;
};

export type InboundSearchResponse = {
    TotalCount?: number;
    InboundMessages?: Array<InboundMessageDetail>;
};

export type MessageClickSearchResponse = {
    TotalCount?: number;
    Clicks?: Array<ExtendedMessageClickEventInformation>;
};

export type MessageEventDetails = {
    Recipient?: string;
    Type?: string;
    ReceivedAt?: string;
    Details?: {
        Summary?: string;
        BounceID?: string;
        DeliveryMessage?: string;
        DestinationServer?: string;
        DestinationIP?: string;
    };
};

/**
 * A single header for an email message.
 */
export type MessageHeader = {
    /**
     * The header's name.
     */
    Name?: string;
    /**
     * The header's value.
     */
    Value?: string;
};

export type MessageOpenSearchResponse = {
    TotalCount?: number;
    Opens?: Array<ExtendedMessageOpenEventInformation>;
};

export type OutboundMessageDetail = {
    Tag?: string;
    MessageID?: string;
    To?: Array<EmailNameAddressPair>;
    Cc?: Array<EmailNameAddressPair>;
    Bcc?: Array<EmailNameAddressPair>;
    Recipients?: Array<(string)>;
    ReceivedAt?: string;
    From?: string;
    Subject?: string;
    Attachments?: AttachmentCollection;
    Status?: string;
    TrackOpens?: boolean;
    TrackLinks?: 'None' | 'HtmlAndText' | 'HtmlOnly' | 'TextOnly';
};

export type OutboundMessageDetailsResponse = {
    TextBody?: string;
    HtmlBody?: string;
    Body?: string;
    Tag?: string;
    MessageID?: string;
    To?: Array<EmailNameAddressPair>;
    Cc?: Array<EmailNameAddressPair>;
    Bcc?: Array<EmailNameAddressPair>;
    Recipients?: Array<(string)>;
    ReceivedAt?: string;
    From?: string;
    Subject?: string;
    Attachments?: AttachmentCollection;
    Status?: string;
    TrackOpens?: boolean;
    TrackLinks?: 'None' | 'HtmlAndText' | 'HtmlOnly' | 'TextOnly';
    MessageEvents?: Array<MessageEventDetails>;
};

export type OutboundMessageDumpResponse = {
    /**
     * Raw source of message. If no dump is available this will return an empty string.
     */
    Body?: string;
};

export type OutboundOverviewStatsResponse = {
    Sent?: number;
    Bounced?: number;
    SMTPAPIErrors?: number;
    BounceRate?: number;
    SpamComplaints?: number;
    SpamComplaintsRate?: number;
    Opens?: number;
    UniqueOpens?: number;
    Tracked?: number;
    WithOpenTracking?: number;
    WithLinkTracking?: number;
    TotalClicks?: number;
    UniqueLinksClicked?: number;
    TotalTrackedLinksSent?: number;
    WithClientRecorded?: number;
    WithPlatformRecorded?: number;
};

export type OutboundSearchResponse = {
    TotalCount?: number;
    Messages?: Array<OutboundMessageDetail>;
};

export type SendEmailBatchRequest = Array<SendEmailRequest>;

export type SendEmailBatchResponse = Array<SendEmailResponse>;

export type SendEmailRequest = {
    /**
     * The sender email address. Must have a registered and confirmed Sender Signature.
     */
    From?: string;
    /**
     * Recipient email address. Multiple addresses are comma seperated. Max 50.
     */
    To?: string;
    /**
     * Recipient email address. Multiple addresses are comma seperated. Max 50.
     */
    Cc?: string;
    /**
     * Bcc recipient email address. Multiple addresses are comma seperated. Max 50.
     */
    Bcc?: string;
    /**
     * Email Subject
     */
    Subject?: string;
    /**
     * Email tag that allows you to categorize outgoing emails and get detailed statistics.
     */
    Tag?: string;
    /**
     * If no TextBody specified HTML email message
     */
    HtmlBody?: string;
    /**
     * If no HtmlBody specified Plain text email message
     */
    TextBody?: string;
    /**
     * Reply To override email address. Defaults to the Reply To set in the sender signature.
     */
    ReplyTo?: string;
    /**
     * Activate open tracking for this email.
     */
    TrackOpens?: boolean;
    /**
     * Replace links in content to enable "click tracking" stats. Default is 'null', which uses the server's LinkTracking setting'.
     */
    TrackLinks?: 'None' | 'HtmlAndText' | 'HtmlOnly' | 'TextOnly';
    Headers?: HeaderCollection;
    Attachments?: AttachmentCollection;
};

/**
 * The standard response when a postmark message is sent
 */
export type SendEmailResponse = {
    To?: string;
    SubmittedAt?: string;
    MessageID?: string;
    ErrorCode?: number;
    Message?: string;
};

export type SendEmailTemplatedBatchRequest = {
    Messages?: Array<EmailWithTemplateRequest>;
};

/**
 * The result of a get sent counts operation.
 */
export type SentCountsResponse = {
    Sent?: number;
    Days?: Array<{
        Date?: string;
        Sent?: number;
    }>;
};

export type ServerConfigurationResponse = {
    ID?: number;
    Name?: string;
    ApiTokens?: Array<(string)>;
    ServerLink?: string;
    Color?: 'purple' | 'blue' | 'turqoise' | 'green' | 'red' | 'yellow' | 'grey';
    InboundAddress?: string;
    RawEmailEnabled?: boolean;
    DeliveryHookUrl?: string;
    SmtpApiActivated?: boolean;
    InboundHookUrl?: string;
    BounceHookUrl?: string;
    OpenHookUrl?: string;
    PostFirstOpenOnly?: boolean;
    TrackOpens?: boolean;
    TrackLinks?: 'None' | 'HtmlAndText' | 'HtmlOnly' | 'TextOnly';
    ClickHookUrl?: string;
    InboundDomain?: string;
    InboundHash?: string;
    InboundSpamThreshold?: number;
};

/**
 * A Postmark API error.
 */
export type StandardPostmarkResponse = {
    ErrorCode?: number;
    Message?: string;
};

export type TemplateDetailResponse = {
    /**
     * The display name for the template.
     */
    Name?: string;
    /**
     * The user-supplied alias for this template.
     */
    Alias?: string;
    /**
     * The ID associated with the template.
     */
    TemplateID?: number;
    /**
     * The content to use for the HtmlBody when this template is used to send email.
     */
    HtmlBody?: string;
    /**
     * The content to use for the TextBody when this template is used to send email.
     */
    TextBody?: string;
    /**
     * The ID of the Server with which this template is associated.
     */
    AssociatedServerId?: number;
    /**
     * The content to use for the Subject when this template is used to send email.
     */
    Subject?: string;
    /**
     * Indicates that this template may be used for sending email.
     */
    Active?: boolean;
};

export type TemplateListingResponse = {
    /**
     * The total number of Templates API associated with this server.
     */
    TotalCount?: number;
    /**
     * Basic information for each Template returned from the query.
     */
    'Templates API'?: Array<TemplateRecordResponse>;
};

export type TemplateRecordResponse = {
    /**
     * The display name for this template.
     */
    Name?: string;
    /**
     * The user-supplied alias for this template.
     */
    Alias?: string;
    /**
     * The associated ID for this template.
     */
    TemplateId?: number;
    /**
     * True if this template is currently available for use.
     */
    Active?: boolean;
};

export type TemplateValidationError = {
    Message?: string;
    Line?: number;
    CharacterPosition?: number;
};

export type TemplateValidationRequest = {
    /**
     * The subject content to validate. Must be specified if HtmlBody or
     * TextBody are not. See our template language documentation for more
     * information on the syntax for this field.
     *
     */
    Subject?: string;
    /**
     * The html body content to validate. Must be specified if Subject or
     * TextBody are not. See our template language documentation for more
     * information on the syntax for this field.
     *
     */
    HtmlBody?: string;
    /**
     * The text body content to validate. Must be specified if HtmlBody or
     * Subject are not. See our template language documentation for more
     * information on the syntax for this field.
     *
     */
    TextBody?: string;
    /**
     * The model to be used when rendering test content.
     */
    TestRenderModel?: {
        [key: string]: unknown;
    };
    /**
     * When HtmlBody is specified, the test render will have style blocks
     * inlined as style attributes on matching html elements. You may disable
     * the css inlining behavior by passing false for this parameter.
     *
     */
    InlineCssForHtmlTestRender?: boolean;
};

export type TemplateValidationResponse = {
    AllContentIsValid?: boolean;
    TextBody?: TemplateValidationResult;
    HtmlBody?: TemplateValidationResult;
    Subject?: TemplateValidationResult;
    SuggestedTemplateModel?: {
        [key: string]: unknown;
    };
};

export type TemplateValidationResult = {
    ContentIsValid?: boolean;
    ValidationErrors?: Array<TemplateValidationError>;
    RenderedContent?: string;
};

export type SendEmailData = {
    body?: SendEmailRequest;
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
};

export type SendEmailResponse2 = (SendEmailResponse);

export type SendEmailError = (StandardPostmarkResponse | unknown);

export type SendEmailBatchData = {
    body?: SendEmailBatchRequest;
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
};

export type SendEmailBatchResponse2 = (SendEmailBatchResponse);

export type SendEmailBatchError = (StandardPostmarkResponse | unknown);

export type GetDeliveryStatsData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
};

export type GetDeliveryStatsResponse = (DeliveryStatsResponse);

export type GetDeliveryStatsError = (StandardPostmarkResponse | unknown);

export type GetBouncesData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query: {
        /**
         * Number of bounces to return per request. Max 500.
         */
        count: number;
        /**
         * Filter by email address
         */
        emailFilter?: string;
        /**
         * Filter messages starting from the date specified. e.g. `2014-02-01`
         */
        fromdate?: string;
        /**
         * Filter by emails that were deactivated by Postmark due to the bounce. Set to true or false. If this isn't specified it will return both active and inactive.
         */
        inactive?: boolean;
        /**
         * Filter by messageID
         */
        messageID?: string;
        /**
         * Number of bounces to skip.
         */
        offset: number;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter messages up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
        /**
         * Filter by type of bounce
         */
        type?: 'HardBounce' | 'Transient' | 'Unsubscribe' | 'Subscribe' | 'AutoResponder' | 'AddressChange' | 'DnsError' | 'SpamNotification' | 'OpenRelayTest' | 'Unknown' | 'SoftBounce' | 'VirusNotification' | 'MailFrontier Matador.' | 'BadEmailAddress' | 'SpamComplaint' | 'ManuallyDeactivated' | 'Unconfirmed' | 'Blocked' | 'SMTPApiError' | 'InboundError' | 'DMARCPolicy' | 'TemplateRenderingFailed';
    };
};

export type GetBouncesResponse = (BounceSearchResponse);

export type GetBouncesError = (StandardPostmarkResponse | unknown);

export type GetSingleBounceData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The ID of the bounce to retrieve.
         */
        bounceid: number;
    };
};

export type GetSingleBounceResponse = (BounceInfoResponse);

export type GetSingleBounceError = (StandardPostmarkResponse | unknown);

export type GetBouncesByBounceidDumpData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The ID for the bounce dump to retrieve.
         */
        bounceid: number;
    };
};

export type GetBouncesByBounceidDumpResponse = (BounceDumpResponse);

export type GetBouncesByBounceidDumpError = (StandardPostmarkResponse | unknown);

export type ActivateBounceData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The ID of the Bounce to activate.
         */
        bounceid: number;
    };
};

export type ActivateBounceResponse = (BounceActivationResponse);

export type ActivateBounceError = (StandardPostmarkResponse | unknown);

export type SearchOutboundMessagesData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query: {
        /**
         * Number of messages to return per request. Max 500.
         */
        count: number;
        /**
         * Filter messages starting from the date specified. e.g. `2014-02-01`
         */
        fromdate?: string;
        /**
         * Filter by the sender email address
         */
        fromemail?: string;
        /**
         * Number of messages to skip
         */
        offset: number;
        /**
         * Filter by the user who was receiving the email
         */
        recipient?: string;
        /**
         * Filter by status (`queued` or `sent`)
         */
        status?: 'queued' | 'sent';
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter messages up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type SearchOutboundMessagesResponse = (OutboundSearchResponse);

export type SearchOutboundMessagesError = (StandardPostmarkResponse | unknown);

export type GetOutboundMessageDetailsData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The ID of the message for which to retrieve details.
         */
        messageid: string;
    };
};

export type GetOutboundMessageDetailsResponse = (OutboundMessageDetailsResponse);

export type GetOutboundMessageDetailsError = (StandardPostmarkResponse | unknown);

export type GetOutboundMessageDumpData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The ID of the message for which to retrieve a dump.
         */
        messageid: string;
    };
};

export type GetOutboundMessageDumpResponse = (OutboundMessageDumpResponse);

export type GetOutboundMessageDumpError = (StandardPostmarkResponse | unknown);

export type SearchInboundMessagesData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query: {
        /**
         * Number of messages to return per request. Max 500.
         */
        count: number;
        /**
         * Filter messages starting from the date specified. e.g. `2014-02-01`
         */
        fromdate?: string;
        /**
         * Filter by the sender email address
         */
        fromemail?: string;
        /**
         * Filter by mailboxhash
         */
        mailboxhash?: string;
        /**
         * Number of messages to skip
         */
        offset: number;
        /**
         * Filter by the user who was receiving the email
         */
        recipient?: string;
        /**
         * Filter by status (`blocked`, `processed`, `queued`, `failed`, `scheduled`)
         */
        status?: 'blocked' | 'processed' | 'queued' | 'failed' | 'scheduled';
        /**
         * Filter by email subject
         */
        subject?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter messages up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type SearchInboundMessagesResponse = (InboundSearchResponse);

export type SearchInboundMessagesError = (StandardPostmarkResponse | unknown);

export type GetInboundMessageDetailsData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The ID of the message for which to details will be retrieved.
         */
        messageid: string;
    };
};

export type GetInboundMessageDetailsResponse = (InboundMessageFullDetailsResponse);

export type GetInboundMessageDetailsError = (StandardPostmarkResponse | unknown);

export type BypassRulesForInboundMessageData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The ID of the message which should bypass inbound rules.
         */
        messageid: string;
    };
};

export type BypassRulesForInboundMessageResponse = (StandardPostmarkResponse);

export type BypassRulesForInboundMessageError = (StandardPostmarkResponse | unknown);

export type RetryInboundMessageProcessingData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The ID of the inbound message on which we should retry processing.
         */
        messageid: string;
    };
};

export type RetryInboundMessageProcessingResponse = (StandardPostmarkResponse);

export type RetryInboundMessageProcessingError = (StandardPostmarkResponse | unknown);

export type SearchOpensForOutboundMessagesData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query: {
        /**
         * Filter by full name of region messages were opened in, i.e. Moscow, New York
         */
        city?: string;
        /**
         * Filter by company, i.e. Microsoft, Apple, Google
         */
        client_company?: string;
        /**
         * Filter by client family, i.e. OS X, Chrome
         */
        client_family?: string;
        /**
         * Filter by client name, i.e. Outlook, Gmail
         */
        client_name?: string;
        /**
         * Number of message opens to return per request. Max 500.
         */
        count: number;
        /**
         * Filter by country messages were opened in, i.e. Denmark, Russia
         */
        country?: string;
        /**
         * Number of messages to skip
         */
        offset: number;
        /**
         * Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation
         */
        os_company?: string;
        /**
         * Filter by kind of OS used without specific version, i.e. OS X, Windows
         */
        os_family?: string;
        /**
         * Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7
         */
        os_name?: string;
        /**
         * Filter by platform, i.e. webmail, desktop, mobile
         */
        platform?: string;
        /**
         * Filter by To, Cc, Bcc
         */
        recipient?: string;
        /**
         * Filter by full name of region messages were opened in, i.e. Moscow, New York
         */
        region?: string;
        /**
         * Filter by tag
         */
        tag?: string;
    };
};

export type SearchOpensForOutboundMessagesResponse = (MessageOpenSearchResponse);

export type SearchOpensForOutboundMessagesError = (StandardPostmarkResponse | unknown);

export type GetOpensForSingleOutboundMessageData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The ID of the Outbound Message for which open statistics should be retrieved.
         */
        messageid: string;
    };
    query: {
        /**
         * Number of message opens to return per request. Max 500.
         */
        count: number;
        /**
         * Number of messages to skip.
         */
        offset: number;
    };
};

export type GetOpensForSingleOutboundMessageResponse = (MessageOpenSearchResponse);

export type GetOpensForSingleOutboundMessageError = (StandardPostmarkResponse | unknown);

export type SearchClicksForOutboundMessagesData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query: {
        /**
         * Filter by full name of region messages were opened in, i.e. Moscow, New York
         */
        city?: string;
        /**
         * Filter by company, i.e. Microsoft, Apple, Google
         */
        client_company?: string;
        /**
         * Filter by client family, i.e. OS X, Chrome
         */
        client_family?: string;
        /**
         * Filter by client name, i.e. Outlook, Gmail
         */
        client_name?: string;
        /**
         * Number of message clicks to return per request. Max 500.
         */
        count: number;
        /**
         * Filter by country messages were opened in, i.e. Denmark, Russia
         */
        country?: string;
        /**
         * Number of messages to skip
         */
        offset: number;
        /**
         * Filter by company which produced the OS, i.e. Apple Computer, Inc., Microsoft Corporation
         */
        os_company?: string;
        /**
         * Filter by kind of OS used without specific version, i.e. OS X, Windows
         */
        os_family?: string;
        /**
         * Filter by full OS name and specific version, i.e. OS X 10.9 Mavericks, Windows 7
         */
        os_name?: string;
        /**
         * Filter by platform, i.e. webmail, desktop, mobile
         */
        platform?: string;
        /**
         * Filter by To, Cc, Bcc
         */
        recipient?: string;
        /**
         * Filter by full name of region messages were opened in, i.e. Moscow, New York
         */
        region?: string;
        /**
         * Filter by tag
         */
        tag?: string;
    };
};

export type SearchClicksForOutboundMessagesResponse = (MessageClickSearchResponse);

export type SearchClicksForOutboundMessagesError = (StandardPostmarkResponse | unknown);

export type GetClicksForSingleOutboundMessageData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The ID of the Outbound Message for which click statistics should be retrieved.
         */
        messageid: string;
    };
    query: {
        /**
         * Number of message clicks to return per request. Max 500.
         */
        count: number;
        /**
         * Number of messages to skip.
         */
        offset: number;
    };
};

export type GetClicksForSingleOutboundMessageResponse = (MessageClickSearchResponse);

export type GetClicksForSingleOutboundMessageError = (StandardPostmarkResponse | unknown);

export type SendEmailWithTemplateData = {
    body: EmailWithTemplateRequest;
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
};

export type SendEmailWithTemplateResponse = (SendEmailResponse);

export type SendEmailWithTemplateError = (StandardPostmarkResponse | unknown);

export type SendEmailBatchWithTemplatesData = {
    body: SendEmailTemplatedBatchRequest;
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
};

export type SendEmailBatchWithTemplatesResponse = (SendEmailBatchResponse);

export type SendEmailBatchWithTemplatesError = (StandardPostmarkResponse | unknown);

export type ListTemplatesData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query: {
        /**
         * The number of Templates to return
         */
        Count: number;
        /**
         * The number of Templates to "skip" before returning results.
         */
        Offset: number;
    };
};

export type ListTemplatesResponse = (TemplateListingResponse);

export type ListTemplatesError = (StandardPostmarkResponse | unknown);

export type PostTemplatesData = {
    body: CreateTemplateRequest;
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
};

export type PostTemplatesResponse = (TemplateRecordResponse);

export type PostTemplatesError = (StandardPostmarkResponse | unknown);

export type GetSingleTemplateData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The 'TemplateID' or 'Alias' value for the Template you wish to retrieve.
         */
        templateIdOrAlias: string;
    };
};

export type GetSingleTemplateResponse = (TemplateDetailResponse);

export type GetSingleTemplateError = (StandardPostmarkResponse | unknown);

export type UpdateTemplateData = {
    body: EditTemplateRequest;
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The 'TemplateID' or 'Alias' value for the Template you wish to update.
         */
        templateIdOrAlias: string;
    };
};

export type UpdateTemplateResponse = (TemplateRecordResponse);

export type UpdateTemplateError = (StandardPostmarkResponse | unknown);

export type DeleteTemplateData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The 'TemplateID' or 'Alias' value for the Template you wish to delete.
         */
        templateIdOrAlias: string;
    };
};

export type DeleteTemplateResponse = (TemplateDetailResponse);

export type DeleteTemplateError = (StandardPostmarkResponse | unknown);

export type TestTemplateContentData = {
    body?: TemplateValidationRequest;
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
};

export type TestTemplateContentResponse = (TemplateValidationResponse);

export type TestTemplateContentError = (StandardPostmarkResponse | unknown);

export type GetOutboundOverviewStatisticsData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type GetOutboundOverviewStatisticsResponse = (OutboundOverviewStatsResponse);

export type GetOutboundOverviewStatisticsError = (StandardPostmarkResponse | unknown);

export type GetSentCountsData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type GetSentCountsResponse = (SentCountsResponse);

export type GetSentCountsError = (StandardPostmarkResponse | unknown);

export type GetBounceCountsData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type GetBounceCountsResponse = ({
    HardBounce?: number;
    SMTPApiError?: number;
    SoftBounce?: number;
    Transient?: number;
    Days?: Array<{
        Date?: string;
        HardBounce?: number;
        SoftBounce?: number;
        SMTPApiError?: number;
        Transient?: number;
    }>;
});

export type GetBounceCountsError = (StandardPostmarkResponse | unknown);

export type GetSpamComplaintsData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type GetSpamComplaintsResponse = ({
    SpamComplaint?: number;
    Days?: Array<{
        Date?: string;
        SpamComplaint?: number;
    }>;
});

export type GetSpamComplaintsError = (StandardPostmarkResponse | unknown);

export type GetTrackedEmailCountsData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        todate?: string;
    };
};

export type GetTrackedEmailCountsResponse = ({
    Tracked?: number;
    Days?: Array<{
        Date?: string;
        Tracked?: number;
    }>;
});

export type GetTrackedEmailCountsError = (StandardPostmarkResponse | unknown);

export type GetOutboundOpenCountsData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type GetOutboundOpenCountsResponse = ({
    Opens?: number;
    Unique?: number;
    Days?: Array<{
        Date?: string;
        Opens?: number;
        Unique?: number;
    }>;
});

export type GetOutboundOpenCountsError = (StandardPostmarkResponse | unknown);

export type GetOutboundOpenCountsByPlatformData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type GetOutboundOpenCountsByPlatformResponse = ({
    Desktop?: number;
    WebMail?: number;
    Mobile?: number;
    Unknown?: number;
    Days?: Array<{
        Date?: string;
        Desktop?: number;
        WebMail?: number;
        Mobile?: number;
        Unknown?: number;
    }>;
});

export type GetOutboundOpenCountsByPlatformError = (StandardPostmarkResponse | unknown);

export type GetOutboundOpenCountsByEmailClientData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type GetOutboundOpenCountsByEmailClientResponse = ({
    Desktop?: number;
    WebMail?: number;
    Mobile?: number;
    Unknown?: number;
    Days?: Array<DynamicResponse>;
});

export type GetOutboundOpenCountsByEmailClientError = (StandardPostmarkResponse | unknown);

export type GetOutboundClickCountsData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type GetOutboundClickCountsResponse = (DynamicResponse);

export type GetOutboundClickCountsError = (StandardPostmarkResponse | unknown);

export type GetOutboundClickCountsByBrowserFamilyData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type GetOutboundClickCountsByBrowserFamilyResponse = ({
    [key: string]: unknown;
});

export type GetOutboundClickCountsByBrowserFamilyError = (StandardPostmarkResponse | unknown);

export type GetOutboundClickCountsByPlatformData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type GetOutboundClickCountsByPlatformResponse = (DynamicResponse);

export type GetOutboundClickCountsByPlatformError = (StandardPostmarkResponse | unknown);

export type GetOutboundClickCountsByLocationData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query?: {
        /**
         * Filter stats starting from the date specified. e.g. `2014-01-01`
         */
        fromdate?: string;
        /**
         * Filter by tag
         */
        tag?: string;
        /**
         * Filter stats up to the date specified. e.g. `2014-02-01`
         */
        todate?: string;
    };
};

export type GetOutboundClickCountsByLocationResponse = (DynamicResponse);

export type GetOutboundClickCountsByLocationError = (StandardPostmarkResponse | unknown);

export type ListInboundRulesData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    query: {
        /**
         * Number of records to return per request.
         */
        count: number;
        /**
         * Number of records to skip.
         */
        offset: number;
    };
};

export type ListInboundRulesResponse = ({
    TotalCount?: number;
    InboundRules?: Array<{
        ID?: number;
        Rule?: string;
    }>;
});

export type ListInboundRulesError = (StandardPostmarkResponse | unknown);

export type CreateInboundRuleData = {
    body?: CreateInboundRuleRequest;
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
};

export type CreateInboundRuleResponse = ({
    ID?: number;
    Rule?: string;
});

export type CreateInboundRuleError = (StandardPostmarkResponse | unknown);

export type DeleteInboundRuleData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
    path: {
        /**
         * The ID of the Inbound Rule that should be deleted.
         */
        triggerid: number;
    };
};

export type DeleteInboundRuleResponse = (StandardPostmarkResponse);

export type DeleteInboundRuleError = (StandardPostmarkResponse | unknown);

export type GetCurrentServerConfigurationData = {
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
};

export type GetCurrentServerConfigurationResponse = (ServerConfigurationResponse);

export type GetCurrentServerConfigurationError = (StandardPostmarkResponse | unknown);

export type EditCurrentServerConfigurationData = {
    /**
     * The settings that should be modified for the current server.
     */
    body?: EditServerConfigurationRequest;
    headers: {
        /**
         * The token associated with the Server on which this request will operate.
         */
        'X-Postmark-Server-Token': string;
    };
};

export type EditCurrentServerConfigurationResponse = (ServerConfigurationResponse);

export type EditCurrentServerConfigurationError = (StandardPostmarkResponse | unknown);